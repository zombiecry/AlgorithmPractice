<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>Goose Tattarrattat has a sequence B of bits.
Tattarrattat also has a favorite positive integer <b>M</b>.
<b>M</b> divides the number of bits in B.</p>
<br></br>
<p>Tattarrattat wants to have a sequence in which all the bits are 1s.
She will produce such a sequence in a sequence of steps.
In each step she can do one of the following three types of changes to the sequence:</p>
<br></br>
<ul>
<li>Flip any bit (from 1 to 0 or from 0 to 1).</li>
<li>Flip the first k*<b>M</b> bits, for any positive integer k.</li>
<li>Flip the last k*<b>M</b> bits, for any positive integer k.</li>
</ul>
<br></br>
<p>For example, suppose that B="110100001001" and <b>M</b>=4.
There are 17 different sequences Tattarrattat can produce from this B in a single step.
Among those sequences are "100100001001" (flipped the second bit), "001011111001" (flipped the first 2*<b>M</b> bits), and "110100000110" (flipped the last <b>M</b> bits).</p>
<br></br>
<p>You are given a vector &lt;string&gt; <b>S</b> and the int <b>M</b>.
Concatenate all elements of <b>S</b> to obtain one long string.
This string will represent the sequence B: each of its characters will be either '0' or '1'.
Return the minimal number of steps required to obtain a sequence that consists of 1s only.</p></td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>FlippingBitsDiv2</td></tr><tr><td>Method:</td><td>getmin</td></tr><tr><td>Parameters:</td><td>vector &lt;string&gt;, int</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int getmin(vector &lt;string&gt; S, int M)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>64</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>S</b> will contain between 1 and 50 elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>S</b> will contain between 1 and 50 characters, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Each character in each element of <b>S</b> will be '0' or '1'.</td></tr><tr><td align="center" valign="top">-</td><td><b>M</b> will be between 1 and 2500.</td></tr><tr><td align="center" valign="top">-</td><td><b>M</b> will be a divisor of N, where N is the number of characters in <b>S</b>.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;00111000&quot;}</pre></td></tr><tr><td><pre>1</pre></td></tr></table></td></tr><tr><td><pre>Returns: 2</pre></td></tr><tr><td><table><tr><td colspan="2">There are several optimal solutions.
For example, she can flip the first 5*1 bits (obtaining "11000000") and then the last 6*1 bits (obtaining "11111111").
Another solution: she can flip the first 2*1 bits (obtaining "11111000") and then the last 3*1 bits (obtaining "11111111").</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;00111000&quot;}</pre></td></tr><tr><td><pre>2</pre></td></tr></table></td></tr><tr><td><pre>Returns: 3</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;111111&quot;}</pre></td></tr><tr><td><pre>3</pre></td></tr></table></td></tr><tr><td><pre>Returns: 0</pre></td></tr><tr><td><table><tr><td colspan="2">This sequence already consists of 1s only, so no steps are necessary.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;00100&quot;}</pre></td></tr><tr><td><pre>5</pre></td></tr></table></td></tr><tr><td><pre>Returns: 2</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">4)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{&quot;00010&quot;,&quot;11010110&quot;,&quot;1010111&quot;,&quot;110001010&quot;,&quot;0110001100&quot;
,&quot;000110110&quot;,&quot;011010101&quot;,&quot;00&quot;,&quot;111&quot;,&quot;100&quot;}
</pre></td></tr><tr><td><pre>13</pre></td></tr></table></td></tr><tr><td><pre>Returns: 31</pre></td></tr><tr><td><table><tr><td colspan="2">Don't forget to concatenate the elements of <b>S</b>.</td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
